"""Base agent class and common models for proactive intelligence agents.

All agents follow a Monitor â†’ Analyze â†’ Decide â†’ Alert pattern:
1. Monitor: Watch for relevant changes in the world model
2. Analyze: Apply domain-specific reasoning
3. Decide: Determine if insight is actionable
4. Alert: Surface to user if significance threshold met
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any

import structlog

from src.database import Database
from src.world_model import (
    CorrelationService,
    Domain,
    EntityRepository,
    EntityType,
    MentionRepository,
    RelationshipRepository,
    TemporalReasoningService,
    TrendResult,
)

logger = structlog.get_logger()


# ============================================================================
# Alert Models
# ============================================================================


class AlertLevel(str, Enum):
    """Alert severity levels."""

    INFO = "info"  # FYI, no action needed
    WATCH = "watch"  # Monitor this situation
    ACTION = "action"  # Do something about this
    URGENT = "urgent"  # Immediate attention required


class InsightType(str, Enum):
    """Types of insights agents can generate."""

    EMERGING_TECH = "emerging_tech"
    ADOPTION_SPIKE = "adoption_spike"
    NEW_FRAMEWORK = "new_framework"
    SKILL_GAP = "skill_gap"
    PROJECT_IDEA = "project_idea"
    TREND_CHANGE = "trend_change"
    ANOMALY = "anomaly"
    CORRELATION = "correlation"
    CROSS_DOMAIN = "cross_domain"


@dataclass
class Insight:
    """An insight generated by an agent."""

    insight_type: InsightType
    title: str
    description: str
    level: AlertLevel
    confidence: float  # 0.0-1.0
    relevance_score: float  # 0.0-1.0, based on user profile
    entity_ids: list[int] = field(default_factory=list)
    entity_names: list[str] = field(default_factory=list)
    source_ids: list[str] = field(default_factory=list)  # Article/content IDs
    metadata: dict[str, Any] = field(default_factory=dict)
    created_at: datetime = field(default_factory=datetime.utcnow)

    @property
    def priority_score(self) -> float:
        """Calculate priority based on level, confidence, and relevance."""
        level_weights = {
            AlertLevel.INFO: 0.25,
            AlertLevel.WATCH: 0.5,
            AlertLevel.ACTION: 0.75,
            AlertLevel.URGENT: 1.0,
        }
        return level_weights[self.level] * self.confidence * self.relevance_score


@dataclass
class ProjectIdea:
    """A project idea generated from tech trends."""

    title: str
    description: str
    technologies: list[str]
    learning_path: list[str]
    difficulty: str  # beginner, intermediate, advanced
    estimated_hours: int
    rationale: str  # Why this project is relevant
    source_trends: list[str]  # Trends that inspired this idea
    relevance_score: float = 1.0


@dataclass
class AgentReport:
    """Report generated by an agent run."""

    agent_name: str
    domain: Domain
    run_at: datetime
    insights: list[Insight]
    project_ideas: list[ProjectIdea] = field(default_factory=list)
    trends_analyzed: int = 0
    entities_scanned: int = 0
    alerts_generated: int = 0
    execution_time_ms: int = 0
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def summary(self) -> str:
        """Generate a summary of the report."""
        urgent = len([i for i in self.insights if i.level == AlertLevel.URGENT])
        action = len([i for i in self.insights if i.level == AlertLevel.ACTION])
        watch = len([i for i in self.insights if i.level == AlertLevel.WATCH])
        info = len([i for i in self.insights if i.level == AlertLevel.INFO])

        return (
            f"{self.agent_name} Report ({self.run_at.strftime('%Y-%m-%d %H:%M')})\n"
            f"Insights: {len(self.insights)} total "
            f"(ðŸš¨ {urgent} urgent, âš¡ {action} action, ðŸ‘€ {watch} watch, â„¹ï¸ {info} info)\n"
            f"Project Ideas: {len(self.project_ideas)}\n"
            f"Analyzed: {self.trends_analyzed} trends, {self.entities_scanned} entities"
        )


# ============================================================================
# Agent Configuration
# ============================================================================


@dataclass
class AgentConfig:
    """Configuration for an agent."""

    enabled: bool = True
    schedule: str = "0 8 * * *"  # Cron expression
    thresholds: dict[str, float] = field(default_factory=dict)
    focus_areas: list[str] = field(default_factory=list)
    output: dict[str, bool] = field(default_factory=dict)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> "AgentConfig":
        """Create config from dictionary."""
        return cls(
            enabled=data.get("enabled", True),
            schedule=data.get("schedule", "0 8 * * *"),
            thresholds=data.get("thresholds", {}),
            focus_areas=data.get("focus_areas", []),
            output=data.get("output", {}),
        )


@dataclass
class UserProfile:
    """User profile for relevance scoring."""

    role: str = "developer"  # developer, manager, researcher, etc.
    experience_level: str = "senior"  # junior, mid, senior, principal
    interests: list[str] = field(default_factory=list)
    known_technologies: list[str] = field(default_factory=list)
    learning_goals: list[str] = field(default_factory=list)

    def relevance_for_tech(self, tech_name: str, tech_category: str | None = None) -> float:
        """Calculate relevance score for a technology."""
        score = 0.5  # Base relevance

        # Boost if in interests
        if any(
            interest.lower() in tech_name.lower() or tech_name.lower() in interest.lower()
            for interest in self.interests
        ):
            score += 0.3

        # Boost if in learning goals
        if any(
            goal.lower() in tech_name.lower() or tech_name.lower() in goal.lower()
            for goal in self.learning_goals
        ):
            score += 0.2

        # Small boost if related to known tech (adjacent learning)
        if any(known.lower() in tech_name.lower() for known in self.known_technologies):
            score += 0.1

        return min(1.0, score)


# ============================================================================
# Base Agent Class
# ============================================================================


class BaseAgent(ABC):
    """
    Base class for proactive intelligence agents.

    Implements the Monitor â†’ Analyze â†’ Decide â†’ Alert pattern.
    Subclasses must implement domain-specific analysis logic.
    """

    name: str = "base_agent"
    domain: Domain = Domain.GENERAL

    def __init__(
        self,
        db: Database,
        config: AgentConfig | None = None,
        user_profile: UserProfile | None = None,
    ):
        self.db = db
        self.config = config or AgentConfig()
        self.user_profile = user_profile or UserProfile()

        # Initialize repositories and services
        self.entity_repo = EntityRepository(db)
        self.relationship_repo = RelationshipRepository(db)
        self.mention_repo = MentionRepository(db)
        self.temporal_service = TemporalReasoningService(db)
        self.correlation_service = CorrelationService(db)

    async def run(self) -> AgentReport:
        """
        Execute the agent's main loop.

        Returns:
            AgentReport with all insights and metrics
        """
        start_time = datetime.utcnow()
        logger.info(f"Starting {self.name} agent run")

        try:
            # 1. Monitor: Gather relevant data
            monitoring_data = await self.monitor()

            # 2. Analyze: Apply domain-specific reasoning
            insights = await self.analyze(monitoring_data)

            # 3. Decide: Filter insights by thresholds
            filtered_insights = await self.decide(insights)

            # 4. Generate project ideas (if applicable)
            project_ideas = await self.generate_project_ideas(filtered_insights)

            # Calculate execution time
            execution_time = int((datetime.utcnow() - start_time).total_seconds() * 1000)

            report = AgentReport(
                agent_name=self.name,
                domain=self.domain,
                run_at=start_time,
                insights=filtered_insights,
                project_ideas=project_ideas,
                trends_analyzed=monitoring_data.get("trends_count", 0),
                entities_scanned=monitoring_data.get("entities_count", 0),
                alerts_generated=len([i for i in filtered_insights if i.level != AlertLevel.INFO]),
                execution_time_ms=execution_time,
            )

            logger.info(
                f"Completed {self.name} agent run",
                insights=len(filtered_insights),
                project_ideas=len(project_ideas),
                execution_time_ms=execution_time,
            )

            return report

        except Exception as e:
            logger.error(f"Error in {self.name} agent run", error=str(e))
            raise

    @abstractmethod
    async def monitor(self) -> dict[str, Any]:
        """
        Monitor the world model for relevant changes.

        Returns:
            Dictionary with monitoring data for analysis
        """
        pass

    @abstractmethod
    async def analyze(self, monitoring_data: dict[str, Any]) -> list[Insight]:
        """
        Analyze monitoring data and generate insights.

        Args:
            monitoring_data: Data from monitor() step

        Returns:
            List of potential insights
        """
        pass

    async def decide(self, insights: list[Insight]) -> list[Insight]:
        """
        Filter insights based on thresholds and user relevance.

        Default implementation filters by confidence and relevance.
        Subclasses can override for custom filtering.
        """
        min_confidence = self.config.thresholds.get("min_confidence", 0.5)
        min_relevance = self.config.thresholds.get("min_relevance", 0.3)

        filtered = []
        for insight in insights:
            # Apply relevance scoring based on user profile
            if self.user_profile:
                insight.relevance_score = self._calculate_relevance(insight)

            # Filter by thresholds
            if insight.confidence >= min_confidence and insight.relevance_score >= min_relevance:
                filtered.append(insight)

        # Sort by priority
        filtered.sort(key=lambda i: i.priority_score, reverse=True)

        logger.debug(
            "Filtered insights",
            total=len(insights),
            filtered=len(filtered),
            min_confidence=min_confidence,
            min_relevance=min_relevance,
        )

        return filtered

    async def generate_project_ideas(self, insights: list[Insight]) -> list[ProjectIdea]:
        """
        Generate project ideas from insights.

        Default implementation returns empty list.
        Subclasses can override to generate domain-specific ideas.
        """
        return []

    def _calculate_relevance(self, insight: Insight) -> float:
        """Calculate relevance score based on user profile."""
        if not self.user_profile or not insight.entity_names:
            return insight.relevance_score

        # Average relevance across all entities in the insight
        relevances = [
            self.user_profile.relevance_for_tech(name) for name in insight.entity_names
        ]
        return sum(relevances) / len(relevances) if relevances else 0.5

    def _trend_to_alert_level(self, trend: TrendResult) -> AlertLevel:
        """Convert trend magnitude to alert level."""
        abs_change = abs(trend.change_ratio)

        if abs_change >= 2.0:  # 200%+ change
            return AlertLevel.ACTION
        elif abs_change >= 1.0:  # 100%+ change
            return AlertLevel.WATCH
        elif abs_change >= 0.5:  # 50%+ change
            return AlertLevel.INFO
        else:
            return AlertLevel.INFO
